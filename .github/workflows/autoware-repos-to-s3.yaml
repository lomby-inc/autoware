name: Upload to S3 and Deploy to Greengrass

on:
  push:
    branches:
      - feat/MAS-508
    paths:
      - 'autoware.repos'

jobs:
  upload-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-northeast-1

      - name: Upload new 'autoware.repos' file
        run: |
          TIMESTAMP=$(date +%Y-%m-%d_%H-%M-%S)
          aws s3 cp autoware.repos s3://lomby-greengrass/autoware-repos-updates/latest/autoware.repos
          aws s3 cp autoware.repos s3://lomby-greengrass/autoware-repos-updates/archive/$TIMESTAMP-autoware.repos

      - name: Create Greengrass Deployment
        id: create_deployment
        run: |
          # Generate deployment ID with AWS-side validation
          DEPLOYMENT_ID="AutowareUpdate-$(date +%s)-$(openssl rand -hex 4)"
          echo "DEPLOYMENT_ID=$DEPLOYMENT_ID" >> $GITHUB_ENV

          # Create deployment with structured configuration
          aws greengrassv2 create-deployment \
            --target-arn arn:aws:iot:ap-northeast-1:${{ secrets.AWS_ACCOUNT_ID }}:thing/lma2-unit-6 \
            --deployment-name "$DEPLOYMENT_ID" \
            --components '{"AutowareReposUpdater": {"componentVersion": "3.0.0", "configurationUpdate": {"merge": {"DeploymentID": "'"$DEPLOYMENT_ID"'"}}}' \
            --region ap-northeast-1 \
            --output json > deployment-response.json

          # Validate AWS-side deployment creation
          if ! jq -e '.deploymentId' deployment-response.json >/dev/null; then
            echo "::error::Deployment creation failed"
            cat deployment-response.json
            exit 1
          fi

      - name: Validate Deployment ID
        run: |
          if [ -z "$DEPLOYMENT_ID" ]; then
            echo "::error::Deployment ID not generated"
            exit 1
          fi
          if [[ ! "$DEPLOYMENT_ID" =~ ^[A-Za-z0-9_-]+$ ]]; then
            echo "::error::Invalid Deployment ID format: $DEPLOYMENT_ID"
            exit 1
          fi

      - name: Check Deployment Status
        id: check_status
        run: |
          MAX_ATTEMPTS=45  # Increased from 30
          ATTEMPT=0
          SLEEP_DURATION=20
          DEPLOYMENT_ID="${{ env.DEPLOYMENT_ID }}"

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            echo "Attempt $((ATTEMPT+1))/$MAX_ATTEMPTS"
            
            # Get full deployment details
            if ! DEPLOYMENT_JSON=$(aws greengrassv2 get-deployment \
              --deployment-id "$DEPLOYMENT_ID" \
              --output json 2>&1); then
              
              if [[ "$DEPLOYMENT_JSON" == *"ResourceNotFoundException"* ]]; then
                echo "Deployment not found yet, retrying..."
                sleep $SLEEP_DURATION
                ATTEMPT=$((ATTEMPT+1))
                continue
              else
                echo "::error::AWS CLI Error: $DEPLOYMENT_JSON"
                exit 1
              fi
            fi

            STATUS=$(jq -r '.deploymentStatus' <<< "$DEPLOYMENT_JSON")
            ERROR_REASON=$(jq -r '.errorReason // empty' <<< "$DEPLOYMENT_JSON")
            
            echo "Status: $STATUS"
            [[ -n "$ERROR_REASON" ]] && echo "Error Reason: $ERROR_REASON"
            
            case "$STATUS" in
              "COMPLETED")
                echo "status=SUCCESS" >> $GITHUB_OUTPUT
                break
                ;;
              "FAILED")
                echo "::error::Deployment failed with reason: $ERROR_REASON"
                # Fetch component error details
                aws greengrassv2 list-components --output json | jq '.components[] | select(.componentName == "AutowareReposUpdater")'
                exit 1
                ;;
              *)
                sleep $SLEEP_DURATION
                ATTEMPT=$((ATTEMPT+1))
                ;;
            esac
          done

          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "::error::Deployment status check timed out"
            exit 1
          fi

      - name: Monitor Colcon Build
        id: monitor_build
        run: |
          MAX_ATTEMPTS=60
          ATTEMPT=0
          STATUS_FILE="autoware-repos-updates/build-status/${{ env.DEPLOYMENT_ID }}-status.txt"
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            aws s3 ls s3://lomby-greengrass/$STATUS_FILE && {
              aws s3 cp s3://lomby-greengrass/$STATUS_FILE build_status.txt
              STATUS=$(cat build_status.txt)
              echo "build_status=$STATUS" >> $GITHUB_OUTPUT
              break
            }
            ATTEMPT=$((ATTEMPT+1))
            sleep 20
          done
          
          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "build_status=TIMEOUT" >> $GITHUB_OUTPUT
          fi

      #yet to implement
      # - name: Slack Notification
      #   uses: rtCamp/action-slack-notify@v2
      #   env:
      #     SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
      #     SLACK_COLOR: ${{ contains(steps.monitor_build.outputs.build_status, 'SUCCESS') && 'good' || 'danger' }}
      #     SLACK_TITLE: "Build Status: ${{ steps.monitor_build.outputs.build_status }}"
      #     SLACK_MESSAGE: |
      #       *Deployment ID*: ${DEPLOYMENT_ID:0:6}...${DEPLOYMENT_ID: -6}
      #       *Duration*: $((ATTEMPT * 20))s
      #       *Result*: ${{ steps.monitor_build.outputs.build_status }}
      #   if: always()

      - name: Final Status
        run: |
          case "${{ steps.monitor_build.outputs.build_status }}" in
            "SUCCESS") echo "All steps completed successfully" ;;
            "FAILED") echo "Build failed" && exit 1 ;;
            "TIMEOUT") echo "Build timed out" && exit 1 ;;
            *) echo "Unknown status" && exit 1 ;;
          esac
